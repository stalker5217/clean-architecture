## 단일 책임 원칙(SRP : Single Response Principle)  

**"하나의 모듈은 하나의 Actor에 대한 책임만을 져야 한다."**

> 단일 책임 원칙이라는 말만 듣는다면, 하나의 함수가 하나의 기능만을 해야한다는 원칙과 혼동하기 쉽다.
> 이는 SOLID에서 다루는 모듈의 레벨이 아니라, 커다란 함수를 리팩토링을 한다던지 할 때 나타나는 좀 더 저수준의 원칙이다. 


SRP를 위반한 사례를 확인해보자.

![SRP](/images/SRP.png)

- ```calculatePay()``` : 회계팀에서 기능을 정의
- ```reportHours()``` : 인사팀에서 기능을 정의
- ```save()``` : 데이터베이스 관리자가 기능을 정의

클래스를 이와 같이 구성함으로써 세 액터에 대한 기능이 결합되었다. 
높은 결합도로 인해 서로 간의 기능 수정이 영향을 미친다. 

예를 들어, 초과 근무를 제외한 업무 시간을 계산하는 메소드를 구하는 ```getRegularHours()```를 
```calculatePay()```, ```reportHours()```에서 공통으로 사용하고 있다고 가정하자.  

이 때 인사팀에서 초과 근무 시간에 대한 변경을 요청한다. 
하지만 이는 인사팀 내부적으로 확인을 위함이기에 회계팀 입장에서는 변경 없이 그대로 로직을 가져가야 한다. 
이 때 개발자가 인지를 하고 이를 분리하여 기능을 각각 처리해주는 것이 아니라 
단순히 ```reportHours()``` 만 수정을 한다면, 회계팀에서 사용하는 ```calculatePay()```에 영향을 미치고 제대로 돌지 않는다. 

또한, 이러한 경우에는 Source Conflict가 많이 발생한다. 
만약 인사팀에서 요청한 기능 변경과 DBA가 요청한 기능 변경을 두 명의 개발자가 각각 수행한다고 가정하면, 
이 모듈은 여러 액터가 하나로 묶인 상황이기 때문에 필연적으로 conflict가 발생할 수 밖에 없다.

가장 확실한 해결책은 결국 클래스와 메소드의 분리이다. 

이는 퍼사드 패턴을 적용하여 데이터와 기능들을 모두 분리할 수도 있다.

![SRP2](/images/SRP2.png)  

또는, Employee 객체에서 하나의 액터는 그대로 두고 나머지 2개를 퍼사드 패턴으로 분리할 수도 있다.

![SRP3](/images/SRP3.png)